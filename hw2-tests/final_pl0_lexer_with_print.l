/* $Id: pl0_lexer_definitions_top.l,v 1.2 2023/10/06 11:12:37 leavens Exp leavens $ */
/* Lexical Analyzer for PL/0 */

%option header-file = "pl0_lexer.h"
%option outfile = "pl0_lexer.c"
%option yylineno
%option bison-bridge

%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <limits.h>
#include "ast.h"
#include "parser_types.h"
#include "utilities.h"
#include "lexer.h"

 /* Tokens generated by Bison */
#include "pl0.tab.h"

 /* need declaration of fileno, part of the C standard library.
   (Putting an extern declaration here shuts off a gcc warning.) */
extern int fileno(FILE *stream);

/* The filename of the file being read */
char *filename;

/* Have any errors been noted? */
bool errors_noted;

/* The value of a token */
extern YYSTYPE yylval;

/* The FILE used by the generated lexer */
extern FILE *yyin;

#undef yywrap   /* sometimes a macro by default */

// apparently strdup is not declared in <string.h>
extern char *strdup(const char *s);

// set the lexer's value for a token in yylval as an AST
static void tok2ast(int code) {
    AST t;
    t.token.file_loc = file_location_make(filename, yylineno);
    t.token.type_tag = token_ast;
    t.token.code = code;
    t.token.text = strdup(yytext);
    yylval = t;
}

static void ident2ast(const char *name) {
    AST t;
    t.ident.file_loc = file_location_make(filename, yylineno);
    t.ident.type_tag = ident_ast;
    t.ident.name = strdup(name);
    yylval = t;
}

static void number2ast(unsigned int val)
{
    AST t;
    t.number.file_loc = file_location_make(filename, yylineno);
    t.number.type_tag = number_ast;
    t.number.text = strdup(yytext);
    t.number.value = val;
    yylval = t;
}

%}

/* you can add actual definitions below */
DIGIT	        [0-9]
UNSIGNEDNUMBER  (((0x)[0-9A-Fa-f]+)|{DIGIT}+)
LETTER		    [_a-zA-Z]
LETTERORDIGIT	({LETTER}|{DIGIT})
IDENT		    {LETTER}({LETTERORDIGIT}*)
NUMBER          {DIGIT}({DIGIT}*)
NEWLINE         \n
CR              \\r
EOL             ({NEWLINE}|({CR}{NEWLINE}))
COMMENTSTART    #
COMMENT         {COMMENTSTART}.*
IGNORED         [ \t\v\f\r]

/* the rules section starts after the %%
/* Definitions section */

/* Regular expressions for basic token types */
letter           [_a-zA-Z]
digit            [0-9]
letter_or_digit  {letter}|{digit}
ident            {letter}{letter_or_digit}*
number           {digit}+
punctuation      [.;=,()\+\-\*/]
reserved_word    const|var|procedure|call|begin|end|if|then|else|while|do|read|write|skip|odd
rel_ops          <>|<|<=|>|>=
blank            [ ]
tab              [	]
vt               []
formfeed         []
newline          [
]
cr               []
eol              {newline}|{cr}{newline}
comment          #[^\n]*{newline}
 below */


%%
/* Adjusted Rules section with printing */

[ 	
]+                 {;}   /* Ignore whitespace */
{comment}                {;}   /* Ignore comments */

{ident}                  { ident2ast(yytext); printf("IDENT: %s\n", yytext); return IDENT; }       /* Identifier token */
{number}                 { number2ast(atoi(yytext)); printf("NUMBER: %s\n", yytext); return NUMBER; }      /* Number token */
{punctuation}            { tok2ast(PUNCTUATION); printf("PUNCTUATION: %s\n", yytext); return PUNCTUATION; } /* Punctuation token */

/* Reserved words */
"const"                  { tok2ast(CONST); printf("RESERVED_WORD: %s\n", yytext); return CONST; }
"var"                    { tok2ast(VAR); printf("RESERVED_WORD: %s\n", yytext); return VAR; }
"procedure"              { tok2ast(PROCEDURE); printf("RESERVED_WORD: %s\n", yytext); return PROCEDURE; }
"call"                   { tok2ast(CALL); printf("RESERVED_WORD: %s\n", yytext); return CALL; }
"begin"                  { tok2ast(BEGIN); printf("RESERVED_WORD: %s\n", yytext); return BEGIN; }
"end"                    { tok2ast(END); printf("RESERVED_WORD: %s\n", yytext); return END; }
"if"                     { tok2ast(IF); printf("RESERVED_WORD: %s\n", yytext); return IF; }
"then"                   { tok2ast(THEN); printf("RESERVED_WORD: %s\n", yytext); return THEN; }
"else"                   { tok2ast(ELSE); printf("RESERVED_WORD: %s\n", yytext); return ELSE; }
"while"                  { tok2ast(WHILE); printf("RESERVED_WORD: %s\n", yytext); return WHILE; }
"do"                     { tok2ast(DO); printf("RESERVED_WORD: %s\n", yytext); return DO; }
"read"                   { tok2ast(READ); printf("RESERVED_WORD: %s\n", yytext); return READ; }
"write"                  { tok2ast(WRITE); printf("RESERVED_WORD: %s\n", yytext); return WRITE; }
"skip"                   { tok2ast(SKIP); printf("RESERVED_WORD: %s\n", yytext); return SKIP; }
"odd"                    { tok2ast(ODD); printf("RESERVED_WORD: %s\n", yytext); return ODD; }

/* Relational operators */
"="                      { tok2ast(EQ); printf("REL_OP: %s\n", yytext); return EQ; }
"<>"                     { tok2ast(NEQ); printf("REL_OP: %s\n", yytext); return NEQ; }
"<"                      { tok2ast(LT); printf("REL_OP: %s\n", yytext); return LT; }
"<="                     { tok2ast(LTE); printf("REL_OP: %s\n", yytext); return LTE; }
">"                      { tok2ast(GT); printf("REL_OP: %s\n", yytext); return GT; }
">="                     { tok2ast(GTE); printf("REL_OP: %s\n", yytext); return GTE; }
static void tok2ast(int code) {
    AST t;
    t.token.file_loc = file_location_make(filename, yylineno);
    t.token.type_tag = token_ast;
    t.token.code = code;
    t.token.text = strdup(yytext);
    yylval = t;
}
static void ident2ast(const char *name) {
    AST t;
    t.ident.file_loc = file_location_make(filename, yylineno);
    t.ident.type_tag = ident_ast;
    t.ident.name = strdup(name);
    yylval = t;
}

/* Adjusted rules section with printing and using appropriate functions */

[ 	
]+                 {;}   /* Ignore whitespace */
{comment}                {;}   /* Ignore comments */

{ident}                  { ident2ast(yytext); printf("IDENT: %s\n", yytext); return IDENT; }       /* Identifier token */
{number}                 { tok2ast(NUMBER); printf("NUMBER: %s\n", yytext); return NUMBER; }      /* Number token */
{punctuation}            { tok2ast(PUNCTUATION); printf("PUNCTUATION: %s\n", yytext); return PUNCTUATION; } /* Punctuation token */

/* Reserved words */
"const"                  { tok2ast(CONST); printf("RESERVED_WORD: %s\n", yytext); return CONST; }
"var"                    { tok2ast(VAR); printf("RESERVED_WORD: %s\n", yytext); return VAR; }
"procedure"              { tok2ast(PROCEDURE); printf("RESERVED_WORD: %s\n", yytext); return PROCEDURE; }
"call"                   { tok2ast(CALL); printf("RESERVED_WORD: %s\n", yytext); return CALL; }
"begin"                  { tok2ast(BEGIN); printf("RESERVED_WORD: %s\n", yytext); return BEGIN; }
"end"                    { tok2ast(END); printf("RESERVED_WORD: %s\n", yytext); return END; }
"if"                     { tok2ast(IF); printf("RESERVED_WORD: %s\n", yytext); return IF; }
"then"                   { tok2ast(THEN); printf("RESERVED_WORD: %s\n", yytext); return THEN; }
"else"                   { tok2ast(ELSE); printf("RESERVED_WORD: %s\n", yytext); return ELSE; }
"while"                  { tok2ast(WHILE); printf("RESERVED_WORD: %s\n", yytext); return WHILE; }
"do"                     { tok2ast(DO); printf("RESERVED_WORD: %s\n", yytext); return DO; }
"read"                   { tok2ast(READ); printf("RESERVED_WORD: %s\n", yytext); return READ; }
"write"                  { tok2ast(WRITE); printf("RESERVED_WORD: %s\n", yytext); return WRITE; }
"skip"                   { tok2ast(SKIP); printf("RESERVED_WORD: %s\n", yytext); return SKIP; }
"odd"                    { tok2ast(ODD); printf("RESERVED_WORD: %s\n", yytext); return ODD; }

/* Relational operators */
"="                      { tok2ast(EQ); printf("REL_OP: %s\n", yytext); return EQ; }
"<>"                     { tok2ast(NEQ); printf("REL_OP: %s\n", yytext); return NEQ; }
"<"                      { tok2ast(LT); printf("REL_OP: %s\n", yytext); return LT; }
"<="                     { tok2ast(LTE); printf("REL_OP: %s\n", yytext); return LTE; }
">"                      { tok2ast(GT); printf("REL_OP: %s\n", yytext); return GT; }
">="                     { tok2ast(GTE); printf("REL_OP: %s\n", yytext); return GTE; }

/* Rules section with utility functions */

[ 	
]+                 {;}   /* Ignore whitespace */
{comment}                {;}   /* Ignore comments */

{ident}                  { ident2ast(yytext); printf("IDENT: %s\n", yytext); return IDENT; }       /* Identifier token */
{number}                 { number2ast(atoi(yytext)); printf("NUMBER: %s\n", yytext); return NUMBER; }      /* Number token */
{punctuation}            { reg2ast(PUNCTUATION); printf("PUNCTUATION: %s\n", yytext); return PUNCTUATION; } /* Punctuation token */

/* Reserved words */
"const"                  { reg2ast(CONST); printf("RESERVED_WORD: %s\n", yytext); return CONST; }
"var"                    { reg2ast(VAR); printf("RESERVED_WORD: %s\n", yytext); return VAR; }
"procedure"              { reg2ast(PROCEDURE); printf("RESERVED_WORD: %s\n", yytext); return PROCEDURE; }
"call"                   { reg2ast(CALL); printf("RESERVED_WORD: %s\n", yytext); return CALL; }
"begin"                  { reg2ast(BEGIN); printf("RESERVED_WORD: %s\n", yytext); return BEGIN; }
"end"                    { reg2ast(END); printf("RESERVED_WORD: %s\n", yytext); return END; }
"if"                     { reg2ast(IF); printf("RESERVED_WORD: %s\n", yytext); return IF; }
"then"                   { reg2ast(THEN); printf("RESERVED_WORD: %s\n", yytext); return THEN; }
"else"                   { reg2ast(ELSE); printf("RESERVED_WORD: %s\n", yytext); return ELSE; }
"while"                  { reg2ast(WHILE); printf("RESERVED_WORD: %s\n", yytext); return WHILE; }
"do"                     { reg2ast(DO); printf("RESERVED_WORD: %s\n", yytext); return DO; }
"read"                   { reg2ast(READ); printf("RESERVED_WORD: %s\n", yytext); return READ; }
"write"                  { reg2ast(WRITE); printf("RESERVED_WORD: %s\n", yytext); return WRITE; }
"skip"                   { reg2ast(SKIP); printf("RESERVED_WORD: %s\n", yytext); return SKIP; }
"odd"                    { reg2ast(ODD); printf("RESERVED_WORD: %s\n", yytext); return ODD; }

/* Relational operators */
"="                      { reg2ast(EQ); printf("REL_OP: %s\n", yytext); return EQ; }
"<>"                     { reg2ast(NEQ); printf("REL_OP: %s\n", yytext); return NEQ; }
"<"                      { reg2ast(LT); printf("REL_OP: %s\n", yytext); return LT; }
"<="                     { reg2ast(LTE); printf("REL_OP: %s\n", yytext); return LTE; }
">"                      { reg2ast(GT); printf("REL_OP: %s\n", yytext); return GT; }
">="                     { reg2ast(GTE); printf("REL_OP: %s\n", yytext); return GTE; }

/* Utility functions for creating ASTs for recognized tokens */

static void reg2ast(int code) {
    AST t;
    t.token.file_loc = file_location_make(filename, yylineno);
    t.token.code = code;
    yylval = t;
}

static void ident2ast(const char *name) {
    AST t;
    t.token.file_loc = file_location_make(filename, yylineno);
    t.ident.name = name;
    yylval = t;
}

static void number2ast(unsigned int val) {
    AST t;
    t.token.file_loc = file_location_make(filename, yylineno);
    t.number.val = val;
    yylval = t;
}

/* Rules section with printing */

[ 	
]+                 {;}   /* Ignore whitespace */
{comment}                {;}   /* Ignore comments */

{ident}                  { tok2ast(IDENT); printf("IDENT: %s\n", yytext); return IDENT; }       /* Identifier token */
{number}                 { tok2ast(NUMBER); printf("NUMBER: %s\n", yytext); return NUMBER; }      /* Number token */
{punctuation}            { tok2ast(PUNCTUATION); printf("PUNCTUATION: %s\n", yytext); return PUNCTUATION; } /* Punctuation token */

/* Reserved words */
"const"                  { tok2ast(CONST); printf("RESERVED_WORD: %s\n", yytext); return CONST; }
"var"                    { tok2ast(VAR); printf("RESERVED_WORD: %s\n", yytext); return VAR; }
"procedure"              { tok2ast(PROCEDURE); printf("RESERVED_WORD: %s\n", yytext); return PROCEDURE; }
"call"                   { tok2ast(CALL); printf("RESERVED_WORD: %s\n", yytext); return CALL; }
"begin"                  { tok2ast(BEGIN); printf("RESERVED_WORD: %s\n", yytext); return BEGIN; }
"end"                    { tok2ast(END); printf("RESERVED_WORD: %s\n", yytext); return END; }
"if"                     { tok2ast(IF); printf("RESERVED_WORD: %s\n", yytext); return IF; }
"then"                   { tok2ast(THEN); printf("RESERVED_WORD: %s\n", yytext); return THEN; }
"else"                   { tok2ast(ELSE); printf("RESERVED_WORD: %s\n", yytext); return ELSE; }
"while"                  { tok2ast(WHILE); printf("RESERVED_WORD: %s\n", yytext); return WHILE; }
"do"                     { tok2ast(DO); printf("RESERVED_WORD: %s\n", yytext); return DO; }
"read"                   { tok2ast(READ); printf("RESERVED_WORD: %s\n", yytext); return READ; }
"write"                  { tok2ast(WRITE); printf("RESERVED_WORD: %s\n", yytext); return WRITE; }
"skip"                   { tok2ast(SKIP); printf("RESERVED_WORD: %s\n", yytext); return SKIP; }
"odd"                    { tok2ast(ODD); printf("RESERVED_WORD: %s\n", yytext); return ODD; }

/* Relational operators */
"="                      { tok2ast(EQ); printf("REL_OP: %s\n", yytext); return EQ; }
"<>"                     { tok2ast(NEQ); printf("REL_OP: %s\n", yytext); return NEQ; }
"<"                      { tok2ast(LT); printf("REL_OP: %s\n", yytext); return LT; }
"<="                     { tok2ast(LTE); printf("REL_OP: %s\n", yytext); return LTE; }
">"                      { tok2ast(GT); printf("REL_OP: %s\n", yytext); return GT; }
">="                     { tok2ast(GTE); printf("REL_OP: %s\n", yytext); return GTE; }


/* Requires: fname != NULL
 * Requires: fname is the name of a readable file
 * Initialize the lexer and start it reading from the given file. */
void asm_lexer_init(char *fname) {
   filename = fname;    
   yyin = fopen(fname, "r");
   if (yyin == NULL) {
       bail_with_error("Lexer cannot open %s", fname);
   }
}

// Close the file yyin
// and return 0 to indicate that there are no more files
int yywrap() {
    if (yyin != NULL) {
	int rc = fclose(yyin);
	if (rc == EOF) {
	    bail_with_error("Cannot close %s!", filename);
	}
    }
    filename = NULL;
    return 1;  /* no more input */
}

/* Report an error to the user on stderr */
void yyerror(const char *filename, const char *msg)
{
    fflush(stdout);
    fprintf(stderr, "%s:%d: %s\n", filename, lexer_line(), msg);
}

/* On standard output:
 * Print a message about the file name of the lexer's input
 * and then print a heading for the lexer's output. */
extern void lexer_print_output_header();

/* Print information about the token t to stdout
 * followed by a newline */
extern void lexer_print_token(yytoken_kind_t t, unsigned int tline,
			      const char *txt);

/* Read all the tokens from the input file
 * and print each token on standard output
 * using the format in lexer_print_token */
void lexer_output()
{
    lexer_print_output_header();
    AST dummy;
    yytoken_kind_t t;
    do {
	t = yylex(&dummy);
	if (t == YYEOF) {
	    break;
	}
        if (t != eolsym) {
	    lexer_print_token(t, yylineno, yytext);
        } else {
	    lexer_print_token(t, yylineno, "\\n");
	}
    } while (t != YYEOF);
}

/* Rules section */

[ 	
]+                 {;}   /* Ignore whitespace */
{comment}                {;}   /* Ignore comments */

{ident}                  { return IDENT; }       /* Identifier token */
{number}                 { return NUMBER; }      /* Number token */
{punctuation}            { return PUNCTUATION; } /* Punctuation token */

/* Reserved words */
"const"                  { return CONST; }
"var"                    { return VAR; }
"procedure"              { return PROCEDURE; }
"call"                   { return CALL; }
"begin"                  { return BEGIN; }
"end"                    { return END; }
"if"                     { return IF; }
"then"                   { return THEN; }
"else"                   { return ELSE; }
"while"                  { return WHILE; }
"do"                     { return DO; }
"read"                   { return READ; }
"write"                  { return WRITE; }
"skip"                   { return SKIP; }
"odd"                    { return ODD; }

/* Relational operators */
"="                      { return EQ; }
"<>"                     { return NEQ; }
"<"                      { return LT; }
"<="                     { return LTE; }
">"                      { return GT; }
">="                     { return GTE; }
  /* Rules section */
[ \t\n]+                 {;}   /* Ignore whitespace */
"#"[^\n]*                {;}   /* Ignore comments */
[a-zA-Z][a-zA-Z0-9]*     { return IDENT; }  /* Identifier token */
[0-9]+                    { return NUMBER; } /* Number token */
"const"                   { return CONST; }  /* CONST keyword */
"var"                     { return VAR; }    /* VAR keyword */
"procedure"               { return PROCEDURE; } /* PROCEDURE keyword */
"call"                    { return CALL; }   /* CALL keyword */
"begin"                   { return BEGIN; }  /* BEGIN keyword */
"end"                     { return END; }    /* END keyword */
"if"                      { return IF; }     /* IF keyword */
"then"                    { return THEN; }   /* THEN keyword */
"else"                    { return ELSE; }   /* ELSE keyword */
"while"                   { return WHILE; }  /* WHILE keyword */
"do"                      { return DO; }     /* DO keyword */
"read"                    { return READ; }   /* READ keyword */
"write"                   { return WRITE; }  /* WRITE keyword */
"skip"                    { return SKIP; }   /* SKIP keyword */
"odd"                     { return ODD; }    /* ODD keyword */
[a-zA-Z][a-zA-Z0-9]*     { return IDENT; }  /* Identifier token */
[0-9]+                    { return NUMBER; } /* Number token */
.   { char msgbuf[512];
      sprintf(msgbuf, "invalid character: '%c' ('\\0%o')", *yytext, *yytext);
      yyerror(lexer_filename(), msgbuf);
    }
%%


 // Requires: fname is the name of a readable file
 // Initialize the lexer and start it reading
 // from the given file name
void lexer_init(char *fname)
{
    errors_noted = false;
    yyin = fopen(fname, "r");
    if (yyin == NULL) {
	bail_with_error("Cannot open %s", fname);
    }
    filename = fname;
}

// Close the file yyin
// and return 0 to indicate that there are no more files
int yywrap() {
    if (yyin != NULL) {
	int rc = fclose(yyin);
	if (rc == EOF) {
	    bail_with_error("Cannot close %s!", filename);
	}
    }
    filename = NULL;
    return 1;  /* no more input */
}

// Return the name of the current input file
const char *lexer_filename() {
    return filename;
}

// Return the line number of the next token
unsigned int lexer_line() {
    return yylineno;
}

/* Report an error to the user on stderr */
void yyerror(const char *filename, const char *msg)
{
    fflush(stdout);
    fprintf(stderr, "%s:%d: %s\n", filename, lexer_line(), msg);
    errors_noted = true;
}

// On standard output:
// Print a message about the file name of the lexer's input
// and then print a heading for the lexer's output.
void lexer_print_output_header()
{
    printf("Tokens from file %s\n", lexer_filename());
    printf("%-6s %-4s  %s\n", "Number", "Line", "Text");
}

// Print information about the token t to stdout
// followed by a newline
void lexer_print_token(enum yytokentype t, unsigned int tline,
		       const char *txt)
{
    printf("%-6d %-4d \"%s\"\n", t, tline, txt);
}


/* Read all the tokens from the input file
 * and print each token on standard output
 * using the format in lexer_print_token */
void lexer_output()
{
    lexer_print_output_header();
    AST dummy;
    yytoken_kind_t t;
    do {
	t = yylex(&dummy);
	if (t == YYEOF) {
	    break;
        }
        lexer_print_token(t, yylineno, yytext);
    } while (t != YYEOF);
}
